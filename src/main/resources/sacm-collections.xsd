<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns="http://cisecurity.org/sacm/sacm-collection" xmlns:sacm="http://cisecurity.org/sacm/sacm-collection" xmlns:xsd="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" targetNamespace="http://cisecurity.org/sacm/sacm-collection" version="1">

    <xsd:element name="collections">
        <xsd:annotation>
            <xsd:documentation xml:lang="en">SACM Posture Attribute Collections.</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:sequence>
                <xsd:element ref="sacm:collection" minOccurs="1" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation></xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
            </xsd:sequence>
        </xsd:complexType>
    </xsd:element>
    
    <xsd:element name="collection">
        <xsd:annotation>
            <xsd:documentation></xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:sequence>
                <xsd:element ref="sacm:collection-type" minOccurs="1" maxOccurs="1">
                    <xsd:annotation>
                        <xsd:documentation></xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:element ref="sacm:collection-behaviors" minOccurs="0">
                    <xsd:annotation>
                        <xsd:documentation></xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
                <xsd:choice>
                    <xsd:element ref="sacm:set">
                        <xsd:annotation>
                            <xsd:documentation></xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element ref="sacm:collection-fields">
                        <xsd:annotation>
                            <xsd:documentation></xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:choice>
                <xsd:element ref="sacm:collection-filters" minOccurs="0"></xsd:element>
            </xsd:sequence>
            <xsd:attribute name="collection-id" type="sacm:CollectionIDPattern" use="required"/>
        </xsd:complexType>
    </xsd:element>
    
    <xsd:element name="collection-type">
        <xsd:annotation>
            <xsd:documentation></xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:attribute name="family" type="sacm:FamilyEnumeration" use="required">
                <xsd:annotation>
                    <xsd:documentation></xsd:documentation>
                </xsd:annotation>
            </xsd:attribute>
            <xsd:attribute name="type" type="sacm:FamilyTypeType" use="required">
                <xsd:annotation>
                    <xsd:documentation></xsd:documentation>
                </xsd:annotation>
            </xsd:attribute>
        </xsd:complexType>
    </xsd:element>
    
    <xsd:element name="collection-behaviors">
        <xsd:annotation>
            <xsd:documentation></xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:sequence>
                <xsd:element ref="sacm:behavior" minOccurs="1" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation></xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
            </xsd:sequence>
        </xsd:complexType>
    </xsd:element>
    
    <xsd:element name="behavior">
        <xsd:annotation>
            <xsd:documentation>NOTE: maybe put some restrictions/enumerations on behavior name?</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:attribute name="name" type="xsd:string" use="required">
                <xsd:annotation>
                    <xsd:documentation></xsd:documentation>
                </xsd:annotation>
            </xsd:attribute>
            <xsd:attribute name="value" type="xsd:string" use="required"><xsd:annotation>
                <xsd:documentation></xsd:documentation>
            </xsd:annotation></xsd:attribute>
        </xsd:complexType>
    </xsd:element>
    
    <xsd:element name="collection-fields">
        <xsd:annotation>
            <xsd:documentation></xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:sequence>
                <xsd:element name="collection-field" type="sacm:FieldType" minOccurs="1" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation></xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
            </xsd:sequence>
        </xsd:complexType>
    </xsd:element>
    
    <xsd:element name="collection-filters">
        <xsd:annotation>
            <xsd:documentation></xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    
    <xsd:element name="collection-filter">
        <xsd:annotation>
            <xsd:documentation></xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:sequence>
                <xsd:element name="filter-field" type="sacm:FieldType" minOccurs="1" maxOccurs="unbounded">
                    <xsd:annotation>
                        <xsd:documentation></xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
            </xsd:sequence>
            <xsd:attribute name="action" type="sacm:FilterActionEnumeration"></xsd:attribute>
        </xsd:complexType>
    </xsd:element>
    
    <xsd:element name="set">
        <xsd:annotation>
            <xsd:documentation></xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    
    
    <!-- =============================================================================== -->
    <!-- ===================================  TYPES  =================================== -->
    <!-- =============================================================================== -->
    
    <xsd:simpleType name="CollectionIDPattern">
        <xsd:annotation>
            <xsd:documentation>Define the format for acceptable Collection ids. The format is an integer.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:integer"/>
    </xsd:simpleType>
    
    <xsd:complexType name="FieldType">
        <xsd:annotation>
            <xsd:documentation></xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="name" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en"></xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="datatype" type="sacm:datatypeType" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en"></xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="operation" type="sacm:operationType" use="optional">
                    <xsd:annotation>
                        <xsd:documentation xml:lang="en"></xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>
    
    <xsd:simpleType name="FamilyEnumeration">
        <xsd:annotation>
            <xsd:documentation></xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="android">
                <xsd:annotation>
                    <xsd:documentation>The android value describes the Android mobile operating system.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="apple_ios">
                <xsd:annotation>
                    <xsd:documentation>The apple_ios value describes the iOS mobile operating system.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="asa">
                <xsd:annotation>
                    <xsd:documentation>The asa value describes the Cisco ASA security devices.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="catos">
                <xsd:annotation>
                    <xsd:documentation>The catos value describes the Cisco CatOS operating system.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="ios">
                <xsd:annotation>
                    <xsd:documentation>The ios value describes the Cisco IOS operating system.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="iosxe">
                <xsd:annotation>
                    <xsd:documentation>The iosxe value describes the Cisco IOS-XE operating system.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="junos">
                <xsd:annotation>
                    <xsd:documentation>The junos value describes the Juniper JunOS operating system.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="macos">
                <xsd:annotation>
                    <xsd:documentation>The macos value describes the Mac operating system.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="pixos">
                <xsd:annotation>
                    <xsd:documentation>The pixos value describes the Cisco PIX operating system.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="undefined">
                <xsd:annotation>
                    <xsd:documentation>The undefined value is to be used when the desired family is not available.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="unix">
                <xsd:annotation>
                    <xsd:documentation>The unix value describes the UNIX operating system.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="vmware_infrastructure">
                <xsd:annotation>
                    <xsd:documentation>The vmware_infrastructure value describes VMWare Infrastructure.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="windows">
                <xsd:annotation>
                    <xsd:documentation>The windows value describes the Microsoft Windows operating system.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>
    
    <xsd:simpleType name="FamilyTypeType">
        <xsd:annotation>
            <xsd:documentation></xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string"/>
    </xsd:simpleType>
    
    <xsd:simpleType name="DatatypeEnumeration">
        <xsd:annotation>
            <xsd:documentation></xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="binary">
                <xsd:annotation>
                    <xsd:documentation>The binary datatype is used to represent hex-encoded data that is in raw (non-printable) form. This datatype conforms to the W3C Recommendation for binary data meaning that each binary octet is encoded as a character tuple, consisting of two hexadecimal digits {[0-9a-fA-F]} representing the octet code.  Expected operations within OVAL for binary values are 'equals' and 'not equal'.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="boolean">
                <xsd:annotation>
                    <xsd:documentation>The boolean datatype represents standard boolean data, either true or false.  This datatype conforms to the W3C Recommendation for boolean data meaning that the following literals are legal values: {true, false, 1, 0}.  Expected operations within OVAL for boolean values are 'equals' and 'not equal'.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="evr_string">
                <xsd:annotation>
                    <xsd:documentation>The evr_string datatype represents the epoch, version, and release fields as a single version string. It has the form "EPOCH:VERSION-RELEASE". Comparisons involving this datatype should follow the algorithm of librpm's rpmvercmp() function. Expected operations within OVAL for evr_string values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', and 'less than or equal'.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="debian_evr_string">
                <xsd:annotation>
                    <xsd:documentation>The debian_evr_string datatype represents the epoch, upstream_version, and debian_revision fields, for a Debian package, as a single version string. It has the form "EPOCH:UPSTREAM_VERSION-DEBIAN_REVISION". Comparisons involving this datatype should follow the algorithm outlined in Chapter 5 of the "Debian Policy Manual" (https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version). Note that a null epoch is equivalent to a value of '0'. An implementation of this is the cmpversions() function in dpkg's enquiry.c. Expected operations within OVAL for debian_evr_string values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', and 'less than or equal'.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="fileset_revision">
                <xsd:annotation>
                    <xsd:documentation>The fileset_revision datatype represents the version string related to filesets in HP-UX. An example would be 'A.03.61.00'. For more information, see the HP-UX "Software Distributor Administration Guide" (http://h20000.www2.hp.com/bc/docs/support/SupportManual/c01919399/c01919399.pdf).  Expected operations within OVAL for fileset_version values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', and 'less than or equal'.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="float">
                <xsd:annotation>
                    <xsd:documentation>The float datatype describes standard float data.  This datatype conforms to the W3C Recommendation for float data meaning it is patterned after the IEEE single-precision 32-bit floating point type.  The format consists of a decimal followed, optionally, by the character 'E' or 'e', followed by an integer exponent.  The special values positive and negative infinity and not-a-number have are represented by INF, -INF and NaN, respectively.  Expected operations within OVAL for float values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', and 'less than or equal'.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="ios_version">
                <xsd:annotation>
                    <xsd:documentation>The ios_version datatype describes Cisco IOS Train strings. These are in essence version strings for IOS. Please refer to Cisco's IOS Reference Guide for information on how to compare different Trains as they follow a very specific pattern. Expected operations within OVAL for ios_version values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', and 'less than or equal'.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="int">
                <xsd:annotation>
                    <xsd:documentation>The int datatype describes standard integer data.  This datatype conforms to the W3C Recommendation for integer data which follows the standard mathematical concept of the integer numbers.  (no decimal point and infinite range)  Expected operations within OVAL for int values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', 'less than or equal', 'bitwise and', and 'bitwise or'.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="ipv4_address">
                <xsd:annotation>
                    <xsd:documentation>The ipv4_address datatype represents IPv4 addresses and IPv4 address prefixes. Its value space consists of the set of ordered pairs of integers where the first element of each pair is in the range [0,2^32) (the representable range of a 32-bit unsigned int), and the second is in the range [0,32]. The first element is an address, and the second is a prefix length. </xsd:documentation>
                    <xsd:documentation>The lexical space is dotted-quad CIDR-like notation ('a.b.c.d' where 'a', 'b', 'c', and 'd' are integers from 0-255), optionally followed by a slash ('/') and either a prefix length (an integer from 0-32) or a netmask represented in the dotted-quad notation described previously. Examples of legal values are '192.0.2.0', '192.0.2.0/32', and '192.0.2.0/255.255.255.255'. Additionally, leading zeros are permitted such that '192.0.2.0' is equal to '192.000.002.000'. If a prefix length is not specified, it is implicitly equal to 32.</xsd:documentation>
                    <xsd:documentation>The expected operations within OVAL for ipv4_address values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', 'less than or equal', 'subset of', and 'superset of'. All operations are defined in terms of the value space. Let A and B be ipv4_address values (i.e. ordered pairs from the value space). The following definitions assume that bits outside the prefix have been zeroed out. By zeroing the low order bits, they are effectively ignored for all operations. Implementations of the following operations MUST behave as if this has been done.</xsd:documentation>
                    <xsd:documentation>The following defines how to perform each operation for the ipv4_address datatype. Let P_addr mean the first element of ordered pair P and P_prefix mean the second element.</xsd:documentation>
                    <xsd:documentation>equals: A equals B if and only if A_addr == B_addr and A_prefix == B_prefix.</xsd:documentation>
                    <xsd:documentation>not equal: A is not equal to B if and only if they don't satisfy the criteria for operator "equals".</xsd:documentation>
                    <xsd:documentation>greater than: A is greater than B if and only if A_prefix == B_prefix and A_addr > B_addr. If A_prefix != B_prefix, i.e. prefix lengths are not equal, an error MUST be reported.</xsd:documentation>
                    <xsd:documentation>greater than or equal: A is greater than or equal to B if and only if A_prefix == B_prefix and they satisfy either the criteria for operators "equal" or "greater than". If A_prefix != B_prefix, i.e. prefix lengths are not equal, an error MUST be reported.</xsd:documentation>
                    <xsd:documentation>less than: A is less than B if and only if A_prefix == B_prefix and they don't satisfy the criteria for operator "greater than or equal". If A_prefix != B_prefix, i.e. prefix lengths are not equal, an error MUST be reported.</xsd:documentation>
                    <xsd:documentation>less than or equal: A is less than or equal to B if and only if A_prefix == B_prefix and they don't satisfy the criteria for operator "greater than". If A_prefix != B_prefix, i.e. prefix lengths are not equal, an error MUST be reported.</xsd:documentation>
                    <xsd:documentation>subset of: A is a subset of B if and only if every IPv4 address in subnet A is present in subnet B. In other words, A_prefix >= B_prefix and the high B_prefix bits of A_addr and B_addr are equal.</xsd:documentation>
                    <xsd:documentation>superset of: A is a superset of B if and only if B is a subset of A.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="ipv6_address">
                <xsd:annotation>
                    <xsd:documentation>The ipv6_address datatype represents IPv6 addresses and IPv6 address prefixes. Its value space consists of the set of ordered pairs of integers where the first element of each pair is in the range [0,2^128) (the representable range of a 128-bit unsigned int), and the second is in the range [0,128]. The first element is an address, and the second is a prefix length.</xsd:documentation>
                    <xsd:documentation>The lexical space is CIDR notation given in IETF specification RFC 4291 for textual representations of IPv6 addresses and IPv6 address prefixes (see sections 2.2 and 2.3). If a prefix-length is not specified, it is implicitly equal to 128.</xsd:documentation>
                    <xsd:documentation>The expected operations within OVAL for ipv6_address values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', 'less than or equal', 'subset of', and 'superset of'. All operations are defined in terms of the value space. Let A and B be ipv6_address values (i.e. ordered pairs from the value space). The following definitions assume that bits outside the prefix have been zeroed out. By zeroing the low order bits, they are effectively ignored for all operations. Implementations of the following operations MUST behave as if this has been done.</xsd:documentation>
                    <xsd:documentation>The following defines how to perform each operation for the ipv6_address datatype. Let P_addr mean the first element of ordered pair P and P_prefix mean the second element.</xsd:documentation>
                    <xsd:documentation>equals: A equals B if and only if A_addr == B_addr and A_prefix == B_prefix.</xsd:documentation>
                    <xsd:documentation>not equal: A is not equal to B if and only if they don't satisfy the criteria for operator "equals".</xsd:documentation>   
                    <xsd:documentation>greater than: A is greater than B if and only if A_prefix == B_prefix and A_addr > B_addr. If A_prefix != B_prefix, an error MUST be reported.</xsd:documentation>
                    <xsd:documentation>greater than or equal: A is greater than or equal to B if and only if A_prefix == B_prefix and they satisfy either the criteria for operators "equal" or "greater than". If A_prefix != B_prefix, an error MUST be reported.</xsd:documentation>
                    <xsd:documentation>less than: A is less than B if and only if A_prefix == B_prefix and they don't satisfy the criteria for operator "greater than or equal". If A_prefix != B_prefix, an error MUST be reported.</xsd:documentation>
                    <xsd:documentation>less than or equal: A is less than or equal to B if and only if A_prefix == B_prefix and they don't satisfy the criteria for operator "greater than". If A_prefix != B_prefix, an error MUST be reported.</xsd:documentation>
                    <xsd:documentation>subset of: A is a subset of B if and only if every IPv6 address in subnet A is present in subnet B. In other words, A_prefix >= B_prefix and the high B_prefix bits of A_addr and B_addr are equal.</xsd:documentation>
                    <xsd:documentation>superset of: A is a superset of B if and only if B is a subset of A.</xsd:documentation>                         
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="string">
                <xsd:annotation>
                    <xsd:documentation>The string datatype describes standard string data. This datatype conforms to the W3C Recommendation for string data.  Expected operations within OVAL for string values are 'equals', 'not equal', 'case insensitive equals', 'case insensitive not equal', 'pattern match'.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="version">
                <xsd:annotation>
                    <xsd:documentation>The version datatype represents a value that is a hierarchical list of non-negative integers separated by a single character delimiter.  Note that any non-number character can be used as a delimiter and that different characters can be used within the same version string.  So '#.#-#' is the same as '#.#.#' or '#c#c#' where '#' is any non-negative integer.  Expected operations within OVAL for version values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', and 'less than or equal'.</xsd:documentation>
                    <xsd:documentation>For example '#.#.#' or '#-#-#-#' where the numbers to the left are more significant than the numbers to the right. When performing an 'equals' operation on a version datatype, you should first check the left most number for equality. If that fails, then the values are not equal. If it succeeds, then check the second left most number for equality. Continue checking the numbers from left to right until the last number has been checked. If, after testing all the previous numbers, the last number is equal then the two versions are equal. When performing other operations, such as 'less than', 'less than or equal', 'greater than, or 'greater than or equal', similar logic as above is used. Start with the left most number and move from left to right. For each number, check if it is less than the number you are testing against. If it is, then the version in question is less than the version you are testing against. If the number is equal, then move to check the next number to the right. For example, to test if 5.7.23 is less than or equal to 5.8.0 you first compare 5 to 5. They are equal so you move on to compare 7 to 8. 7 is less than 8 so the entire test succeeds and 5.7.23 is 'less than or equal' to 5.8.0. The difference between the 'less than' and 'less than or equal' operations is how the last number is handled. If the last number is reached, the check should use the given operation (either 'less than' and 'less than or equal') to test the number. For example, to test if 4.23.6 is greater than 4.23.6 you first compare 4 to 4. They are equal so you move on to compare 23 to 23. They are equal so you move on to compare 6 to 6. This is the last number in the version and since 6 is not greater than 6, the entire test fails and 4.23.6 is not greater than 4.23.6.</xsd:documentation>
                    <xsd:documentation>Version strings with a different number of components shall be padded with zeros to make them the same size. For example, if the version strings '1.2.3' and '6.7.8.9' are being compared, then the short one should be padded to become '1.2.3.0'.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>
    
    <xsd:simpleType name="OperationEnumeration">
        <xsd:annotation>
            <xsd:documentation></xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="equals">
                <xsd:annotation>
                    <xsd:documentation>The 'equals' operation returns true if the actual value on the system is equal to the stated entity.  When the specified datatype is a string, this results in a case-sensitive comparison.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="not equal">
                <xsd:annotation>
                    <xsd:documentation>The 'not equal' operation returns true if the actual value on the system is not equal to the stated entity.  When the specified datatype is a string, this results in a case-sensitive comparison.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="case insensitive equals">
                <xsd:annotation>
                    <xsd:documentation>The 'case insensitive equals' operation is meant for string data and returns true if the actual value on the system is equal (using a case insensitive comparison) to the stated entity.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="case insensitive not equal">
                <xsd:annotation>
                    <xsd:documentation>The 'case insensitive not equal' operation is meant for string data and returns true if the actual value on the system is not equal (using a case insensitive comparison) to the stated entity.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="greater than">
                <xsd:annotation>
                    <xsd:documentation>The 'greater than' operation returns true if the actual value on the system is greater than the stated entity.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="less than">
                <xsd:annotation>
                    <xsd:documentation>The 'less than' operation returns true if the actual value on the system is less than the stated entity.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="greater than or equal">
                <xsd:annotation>
                    <xsd:documentation>The 'greater than or equal' operation returns true if the actual value on the system is greater than or equal to the stated entity.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="less than or equal">
                <xsd:annotation>
                    <xsd:documentation>The 'less than or equal' operation returns true if the actual value on the system is less than or equal to the stated entity.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="bitwise and">
                <xsd:annotation>
                    <xsd:documentation>The 'bitwise and' operation is used to determine if a specific bit is set. It returns true if performing a BITWISE AND with the binary representation of the stated entity against the binary representation of the actual value on the system results in a binary value that is equal to the binary representation of the stated entity. For example, assuming a datatype of 'int', if the actual integer value of the setting on your machine is 6 (same as 0110 in binary), then performing a 'bitwise and' with the stated integer 4 (0100) returns 4 (0100). Since the result is the same as the state mask, then the test returns true. If the actual value on your machine is 1 (0001), then the 'bitwise and' with the stated integer 4 (0100) returns 0 (0000). Since the result is not the same as the stated mask, then the test fails.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="bitwise or">
                <xsd:annotation>
                    <xsd:documentation>The 'bitwise or' operation is used to determine if a specific bit is not set. It returns true if performing a BITWISE OR with the binary representation of the stated entity against the binary representation of the actual value on the system results in a binary value that is equal to the binary representation of the stated entity. For example, assuming a datatype of 'int', if the actual integer value of the setting on your machine is 6 (same as 0110 in binary), then performing a 'bitwise or' with the stated integer 14 (1110) returns 14 (1110). Since the result is the same as the state mask, then the test returns true. If the actual value on your machine is 1 (0001), then the 'bitwise or' with the stated integer 14 (1110) returns 15 (1111). Since the result is not the same as the stated mask, then the test fails.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="pattern match">
                <xsd:annotation>
                    <xsd:documentation>The 'pattern match' operation allows an item to be tested against a regular expression. When used by an entity in an OVAL Object, the regular expression represents the unique set of matching items on the system.  OVAL supports a common subset of the regular expression character classes, operations, expressions and other lexical tokens defined within Perl 5's regular expression specification. For more information on the supported regular expression syntax in OVAL see: http://oval.mitre.org/language/about/re_support_5.6.html</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="subset of">
                <xsd:annotation>
                    <xsd:documentation>The 'subset of' operation returns true if the actual set on the system is a subset of the set defined by the stated entity.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="superset of">
                <xsd:annotation>
                    <xsd:documentation>The 'superset of' operation returns true if the actual set on the system is a superset of the set defined by the stated entity.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>
    
    <xsd:simpleType name="FilterActionEnumeration">
        <xsd:annotation>
            <xsd:documentation>The FilterActionEnumeration simple type defines the different options for filtering sets of items.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="exclude">
                <xsd:annotation>
                    <xsd:documentation>The exclude value specifies that all items that match the filter shall be excluded from set that the filter is applied to.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="include">
                <xsd:annotation>
                    <xsd:documentation>The include value specifies that only items that match the filter shall be included in the set that the filter is applied to.</xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
        </xsd:restriction>
    </xsd:simpleType>
</xsd:schema>
